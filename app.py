# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yUcf7yEx0orCGFGHG2hZpZ4QNXCe5bqm
"""

import streamlit as st
import numpy as np
import pydicom
import cv2
import os
import pandas as pd
from io import BytesIO
import torch
import torch.nn as nn
import torchvision.transforms as transforms
from torchvision import models

# Configuración general
st.set_page_config(page_title="Predicción de Calcificaciones - TFM", layout="wide")
MODEL_PATH = "models/mobilenetv2_pytorch.pt"
DATASET_BASE_PATH = "data"

# Cargamos modelo
@st.cache_resource
def load_model():
    model = models.mobilenet_v2(pretrained=False)
    model.classifier[1] = nn.Sequential(
        nn.Dropout(0.4),
        nn.Linear(model.last_channel, 1)
    )
    model.load_state_dict(torch.load(MODEL_PATH, map_location=torch.device("cpu")))
    model.eval()
    return model

model = load_model()

# Transformación para imágenes (normalización imagenNet)
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Resize((224, 224)),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# Preprocesamiento de DICOM
def preprocess_dicom(dicom_file):
    ds = pydicom.dcmread(dicom_file)
    image = ds.pixel_array.astype(np.float32)
    image -= np.min(image)
    image /= (np.max(image) + 1e-8)
    image_uint8 = np.uint8(image * 255)

    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    clahe_img = clahe.apply(image_uint8)

    resized_img = cv2.resize(clahe_img, (224, 224), interpolation=cv2.INTER_AREA)
    rgb_img = np.stack([resized_img] * 3, axis=-1)
    transformed = transform(rgb_img)
    input_tensor = transformed.unsqueeze(0)  # añadir batch
    return image_uint8, clahe_img, input_tensor

# Branding
st.sidebar.title("TFM: Detección de Calcificaciones")
st.sidebar.image(os.path.join(DATASET_BASE_PATH, "logo.png"), width=200)
st.sidebar.markdown(
    """
    <b>TFM:</b> Predicción de calcificaciones en mamografías<br>
    <b>Autor:</b> Elias Pallarès, Borja Nuñez y Martín Mazuera<br>
    <b>Tutor:</b> Alexandra Abós<br>
    <b>Universidad:</b> UPF-BSM<br>
    <b>Fecha:</b> Junio 2025
    """,
    unsafe_allow_html=True
)

# Selección de dataset e imagen
dataset_options = ["CBIS-DDSM", "CMMD"]
selected_dataset = st.sidebar.selectbox("Selecciona un dataset", dataset_options)
dataset_path = os.path.join(DATASET_BASE_PATH, selected_dataset)
available_images = [f for f in os.listdir(dataset_path) if f.endswith(".dcm")]
selected_image = st.sidebar.selectbox("Selecciona una imagen de ejemplo", available_images)
dicom_path = os.path.join(dataset_path, selected_image)
dicom_batch_files = st.sidebar.file_uploader("Sube imágenes DICOM por lote", type=["dcm"], accept_multiple_files=True)

# Predicción individual
st.title("Predicción de Calcificaciones en Mamografías")

try:
    original_img, clahe_img, input_tensor = preprocess_dicom(dicom_path)
    with torch.no_grad():
        output = model(input_tensor)
        prediction = torch.sigmoid(output).item()
    pred_label = "Maligno" if prediction > 0.5 else "Benigno"
    prob = round(float(prediction), 3)

    col1, col2 = st.columns(2)
    col1.image(clahe_img, caption="Imagen preprocesada (CLAHE)", use_container_width=True)
    col2.markdown(f"### Predicción: `{pred_label}`\nProbabilidad: `{prob}`")

except Exception as e:
    st.error(f"Error procesando la imagen: {e}")

# Predicción por lotes
if dicom_batch_files:
    st.subheader("Predicciones por lote")
    results = []
    for file in dicom_batch_files:
        try:
            _, _, input_tensor = preprocess_dicom(file)
            with torch.no_grad():
                output = model(input_tensor)
                prediction = torch.sigmoid(output).item()
            label = "Maligno" if prediction > 0.5 else "Benigno"
            results.append({"Archivo": file.name, "Probabilidad": round(float(prediction), 3), "Clasificación": label})
        except Exception as e:
            results.append({"Archivo": file.name, "Probabilidad": "Error", "Clasificación": str(e)})

    df_results = pd.DataFrame(results)
    st.dataframe(df_results)

    # Descarga en Excel
    towrite = BytesIO()
    with pd.ExcelWriter(towrite, engine='openpyxl') as writer:
        df_results.to_excel(writer, index=False, sheet_name='Resultados')
    towrite.seek(0)
    st.download_button("Descargar resultados Excel", data=towrite, file_name="predicciones_batch.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

# Pie de página
st.markdown("---")
st.markdown("© 2025 Elias Pallarès Borja Nuñez Martín Mazuera – TFM – UPF-BSM")